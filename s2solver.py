import re
import streamlit as st
from collections import defaultdict

def run_degree_of_saturation(graph_content):
    """
    Implements the Degree of Saturation (DSATUR) algorithm for graph coloring.
    :param graph_content: The graph definition as a string.
    :return: A string representing the coloring of the graph.
    """
    # Parse the graph content to extract vertices and edges
    vertices = set()
    edges = defaultdict(list)

    for line in graph_content.strip().splitlines():
        match = re.match(r"(\w+)\s*-\s*(\w+)", line.strip())
        if match:
            v1, v2 = match.groups()
            vertices.add(v1)
            vertices.add(v2)
            edges[v1].append(v2)
            edges[v2].append(v1)

    # Initialize data structures for DSATUR
    colors = {}
    saturation_degree = {v: 0 for v in vertices}
    degree = {v: len(edges[v]) for v in vertices}
    available_colors = defaultdict(lambda: set())

    # Color the vertices using DSATUR
    while len(colors) < len(vertices):
        # Select the vertex with the highest saturation degree (ties broken by highest degree)
        candidate_vertex = max(
            vertices - colors.keys(),
            key=lambda v: (saturation_degree[v], degree[v])
        )

        # Assign the smallest possible color
        forbidden_colors = {colors[neighbor] for neighbor in edges[candidate_vertex] if neighbor in colors}
        color = 1
        while color in forbidden_colors:
            color += 1

        colors[candidate_vertex] = color

        # Update saturation degree for neighbors
        for neighbor in edges[candidate_vertex]:
            if neighbor not in colors:
                saturation_degree[neighbor] += 1

    # Format the output in the expected (vertex color) format
    coloring_output = "\n".join([f"({v} {c})" for v, c in colors.items()])
    return coloring_output

# # Example usage in the app (if CSP is not solved by the LLM):
# if not coloring_correct:
#     st.warning("Reached maximum iterations without a correct coloring.")
#     st.info(
#         "System 1 solver could not solve the graph coloring problem in 5 turns, so invoking System 2 solver."
#     )
#     dos_coloring = run_degree_of_saturation(graph_content)
#     st.markdown(f"#### Coloring generated by Degree of Saturation algorithm:\n{dos_coloring}")
